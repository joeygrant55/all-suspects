/**
 * Generated Mystery Adapter
 * 
 * Converts mysteries generated by the Mystery Architect Agent (GeneratedMystery format)
 * to the universal MysteryBlueprint format.
 */

import type { MysteryBlueprint, CharacterBlueprint, LocationBlueprint, EvidenceBlueprint, TimelineEvent } from '../types/MysteryBlueprint'
import type { GeneratedMystery, Character, Evidence } from '../../server/mystery/mysterySchema'

/**
 * Convert a GeneratedMystery to MysteryBlueprint
 */
export function fromGeneratedMystery(generated: GeneratedMystery): MysteryBlueprint {
  const killerId = generated.killer.characterId
  const killer = generated.suspects.find(s => s.id === killerId)

  if (!killer) {
    throw new Error(`Killer character ${killerId} not found in suspects list`)
  }

  // Convert characters
  const characters: CharacterBlueprint[] = generated.suspects.map(suspect => 
    convertCharacter(suspect, generated, killerId)
  )

  // Extract locations from evidence and timeline
  const locations = extractLocations(generated)

  // Convert evidence
  const evidence: EvidenceBlueprint[] = generated.evidence.map(ev => 
    convertEvidence(ev, generated)
  )

  // Timeline is already in the right format
  const timeline: TimelineEvent[] = generated.timeline

  // Build dialogue unlocks from evidence
  const dialogueUnlocks = buildDialogueUnlocks(evidence)

  // Determine scoring based on difficulty
  const scoring = generateScoring(generated.difficulty, evidence.length, characters.length)

  return {
    id: generated.id,
    title: generateTitle(generated),
    subtitle: generateSubtitle(generated),
    difficulty: generated.difficulty,
    era: extractEra(generated.setting.date),
    setting: {
      location: generated.setting.location,
      date: generated.setting.date,
      event: generated.setting.event,
      weather: extractWeather(generated),
      atmosphere: generateAtmosphere(generated),
      publicKnowledge: extractPublicKnowledge(generated)
    },
    victim: {
      name: generated.victim.name,
      role: generated.victim.role,
      personality: generated.victim.personality,
      causeOfDeath: generated.victim.causeOfDeath,
      secrets: generated.victim.secrets,
      lastSeen: {
        time: generated.victim.lastKnownAlive.time,
        location: generated.victim.lastKnownAlive.location,
        witness: generated.victim.lastKnownAlive.witness
      }
    },
    characters,
    locations,
    evidence,
    timeline,
    solution: {
      killerId: generated.killer.characterId,
      motive: {
        type: generated.killer.motive.type,
        description: generated.killer.motive.description,
        triggerEvent: generated.killer.motive.triggerEvent
      },
      method: {
        weapon: generated.killer.method.weapon,
        poison: generated.killer.method.poison,
        opportunity: generated.killer.method.opportunity
      },
      criticalEvidence: generated.solution.criticalEvidence,
      keyContradictions: generated.solution.keyContradictions,
      logicalChain: generated.solution.logicalChain,
      redHerrings: extractRedHerrings(generated)
    },
    dialogueUnlocks,
    scoring
  }
}

// ============================================================================
// CHARACTER CONVERSION
// ============================================================================

function convertCharacter(
  suspect: Character,
  mystery: GeneratedMystery,
  killerId: string
): CharacterBlueprint {
  const isGuilty = suspect.id === killerId

  return {
    id: suspect.id,
    name: suspect.name,
    role: suspect.role,
    personality: suspect.personality,
    speechPattern: generateSpeechPattern(suspect),
    greeting: generateGreeting(suspect),
    systemPrompt: generateSystemPrompt(suspect, mystery, isGuilty),
    publicInfo: extractPublicInfo(suspect, mystery),
    privateSecrets: suspect.secrets.map(s => s.content),
    alibi: {
      claimed: suspect.alibi.claimed,
      truth: suspect.alibi.truth,
      holes: suspect.alibi.holes
    },
    relationships: convertRelationships(suspect.relationships),
    knowledge: {
      sawSomething: suspect.knowledge.sawSomething,
      whatTheySaw: suspect.knowledge.whatTheySaw,
      whyTheyreHiding: suspect.knowledge.whyTheyreHiding
    },
    isGuilty,
    pressureProfile: {
      threshold: suspect.pressureProfile.threshold,
      weaknesses: suspect.pressureProfile.weaknesses,
      telltales: suspect.pressureProfile.telltales
    },
    videoStyle: {
      cinematography: suspect.videoStyle.cinematography,
      emotionalTone: suspect.videoStyle.emotionalTone,
      visualMotifs: suspect.videoStyle.visualMotifs
    }
  }
}

function generateSpeechPattern(suspect: Character): string {
  // Extract speech patterns from personality if not explicitly defined
  const personality = suspect.personality.toLowerCase()
  
  if (personality.includes('formal') || personality.includes('aristocrat')) {
    return 'Formal, precise, proper grammar. Uses "one" instead of "I".'
  }
  if (personality.includes('nervous') || personality.includes('anxious')) {
    return 'Hesitant, stammers when stressed, trails off mid-sentence.'
  }
  if (personality.includes('charming') || personality.includes('charismatic')) {
    return 'Smooth, persuasive, uses flattery. Calls people "darling" or "my dear".'
  }
  if (personality.includes('gruff') || personality.includes('blunt')) {
    return 'Terse, direct, no-nonsense. Short sentences.'
  }
  
  return 'Natural, conversational tone with personality-appropriate mannerisms.'
}

function generateGreeting(suspect: Character): string {
  const role = suspect.role.toLowerCase()
  const name = suspect.name
  
  // Generate greeting based on role and personality
  if (role.includes('butler') || role.includes('servant')) {
    return `*${name} stands at attention, a model of professional service.*\n\nGood evening. I am at your disposal. How may I assist the investigation?`
  }
  if (role.includes('doctor') || role.includes('physician')) {
    return `*${name} rises from their chair, extending a professional handshake.*\n\nDetective. A terrible business, this. I'll help however I can.`
  }
  if (role.includes('wife') || role.includes('widow')) {
    return `*${name} looks up, composure barely maintained.*\n\nDetective. I... I still can't believe this is happening. What do you need to know?`
  }
  
  return `*${name} regards you carefully as you approach.*\n\nDetective. I assume you have questions.`
}

function generateSystemPrompt(suspect: Character, mystery: GeneratedMystery, isGuilty: boolean): string {
  const secretsList = suspect.secrets.map(s => `- ${s.content}`).join('\n')
  const relationshipsList = Object.entries(suspect.relationships)
    .map(([char, rel]) => `- ${char}: ${rel.description}`)
    .join('\n')

  return `You are ${suspect.name}, ${suspect.role}.

PERSONALITY: ${suspect.personality}

YOUR SECRETS:
${secretsList}

YOUR ALIBI (claimed): ${suspect.alibi.claimed}
YOUR ALIBI (truth): ${suspect.alibi.truth}

RELATIONSHIPS:
${relationshipsList}

${isGuilty ? `
YOU ARE THE KILLER.
- Motive: ${mystery.killer.motive.description}
- Method: ${mystery.killer.method.weapon}
- Trigger: ${mystery.killer.motive.triggerEvent}

DO NOT CONFESS unless confronted with overwhelming evidence (${mystery.solution.criticalEvidence.join(', ')}).
Maintain your claimed alibi: ${suspect.alibi.claimed}
Only crack under extreme pressure when multiple pieces of critical evidence are presented.
` : `
YOU ARE INNOCENT. You did not commit this murder.
- Be truthful about what you know (you saw: ${suspect.knowledge.sawSomething ? suspect.knowledge.whatTheySaw : 'nothing relevant'})
- Protect your secrets, but don't lie about the murder itself
- React naturally to pressure and evidence
`}

PRESSURE PROFILE:
- You crack at pressure level: ${suspect.pressureProfile.threshold}
- Topics that make you nervous: ${suspect.pressureProfile.weaknesses.join(', ')}
- When lying/nervous, you: ${suspect.pressureProfile.telltales.join(', ')}

Stay in character. Respond naturally to questions and evidence.`
}

function extractPublicInfo(suspect: Character, mystery: GeneratedMystery): string {
  // Build public info from role and public relationships
  const publicRelationships = Object.entries(suspect.relationships)
    .filter(([_, rel]) => rel.publicKnowledge)
    .map(([char, rel]) => rel.description)
    .join('. ')
  
  return `${suspect.role}. ${publicRelationships || 'Present at the event.'}`
}

function convertRelationships(relationships: Character['relationships']): Record<string, string> {
  const converted: Record<string, string> = {}
  
  for (const [characterId, relationship] of Object.entries(relationships)) {
    converted[characterId] = relationship.description
  }
  
  return converted
}

// ============================================================================
// LOCATION EXTRACTION
// ============================================================================

function extractLocations(mystery: GeneratedMystery): LocationBlueprint[] {
  // Extract unique locations from timeline and evidence
  const locationSet = new Set<string>()
  
  // From timeline
  mystery.timeline.forEach(event => {
    locationSet.add(event.location)
  })
  
  // From evidence
  mystery.evidence.forEach(ev => {
    locationSet.add(ev.location)
  })
  
  // Convert to LocationBlueprint
  return Array.from(locationSet).map(loc => ({
    id: loc.toLowerCase().replace(/\s+/g, '-'),
    name: loc,
    description: generateLocationDescription(loc, mystery),
    evidenceIds: mystery.evidence
      .filter(ev => ev.location === loc)
      .map(ev => ev.id),
    characterPresent: findCharacterAtLocation(loc, mystery)
  }))
}

function generateLocationDescription(location: string, mystery: GeneratedMystery): string {
  // Generate atmospheric description based on location name
  const loc = location.toLowerCase()
  
  if (loc.includes('study') || loc.includes('library')) {
    return 'A private room lined with books and papers. The scent of leather and tobacco lingers.'
  }
  if (loc.includes('parlor') || loc.includes('sitting') || loc.includes('lounge')) {
    return 'An elegant room for entertaining guests. Comfortable furniture and tasteful decor.'
  }
  if (loc.includes('kitchen') || loc.includes('pantry')) {
    return 'The service area. Cooking implements, supplies, and the bustle of household work.'
  }
  if (loc.includes('garden') || loc.includes('grounds') || loc.includes('outside')) {
    return 'The outdoor area. Fresh air and relative privacy from the house.'
  }
  if (loc.includes('bedroom') || loc.includes('chamber')) {
    return 'A private sleeping chamber. Personal effects and intimate space.'
  }
  
  return `${location}. An important location in the mystery.`
}

function findCharacterAtLocation(location: string, mystery: GeneratedMystery): string | undefined {
  // Check timeline for characters frequently at this location
  const charactersAtLocation = mystery.timeline
    .filter(event => event.location === location)
    .flatMap(event => event.participants)
  
  // Return most common character, if any
  if (charactersAtLocation.length === 0) return undefined
  
  const counts = charactersAtLocation.reduce((acc, char) => {
    acc[char] = (acc[char] || 0) + 1
    return acc
  }, {} as Record<string, number>)
  
  const mostCommon = Object.entries(counts).sort((a, b) => b[1] - a[1])[0]
  return mostCommon ? mostCommon[0] : undefined
}

// ============================================================================
// EVIDENCE CONVERSION
// ============================================================================

function convertEvidence(ev: Evidence, mystery: GeneratedMystery): EvidenceBlueprint {
  return {
    id: ev.id,
    name: ev.name,
    type: inferEvidenceType(ev),
    location: ev.location,
    description: ev.description,
    detailedDescription: expandEvidenceDescription(ev),
    discoveryCondition: ev.discoveryCondition === 'always' ? 'always' :
                        ev.discoveryCondition === 'search' ? 'room-search' :
                        'interrogation',
    forensics: ev.forensics.fingerprints || ev.forensics.bloodType || ev.forensics.timeIndicators ? {
      fingerprints: ev.forensics.fingerprints,
      bloodType: ev.forensics.bloodType,
      timeIndicators: ev.forensics.timeIndicators,
      otherDetails: {}
    } : undefined,
    implications: {
      implicates: ev.implications.implicates,
      exonerates: ev.implications.exonerates,
      reveals: ev.implications.reveals
    },
    hint: generateEvidenceHint(ev),
    relatedCharacter: ev.implications.implicates[0], // Primary suspect
    pointsTo: ev.implications.implicates.length === 1 ? ev.implications.implicates[0] : undefined,
    dialogueUnlocks: generateDialogueUnlocksForEvidence(ev)
  }
}

function inferEvidenceType(ev: Evidence): 'testimony' | 'contradiction' | 'physical' | 'document' {
  const name = ev.name.toLowerCase()
  const desc = ev.description.toLowerCase()
  
  if (name.includes('testimony') || desc.includes('witness') || desc.includes('saw')) {
    return 'testimony'
  }
  if (name.includes('letter') || name.includes('document') || name.includes('note')) {
    return 'document'
  }
  if (name.includes('contradiction') || desc.includes('alibi fails')) {
    return 'contradiction'
  }
  
  return 'physical'
}

function expandEvidenceDescription(ev: Evidence): string {
  // If description is short, expand it
  if (ev.description.length > 100) {
    return ev.description
  }
  
  // Add forensic details
  let expanded = ev.description + '\n\n'
  
  if (ev.forensics.fingerprints && ev.forensics.fingerprints.length > 0) {
    expanded += `Fingerprints detected: ${ev.forensics.fingerprints.join(', ')}.\n`
  }
  if (ev.forensics.bloodType) {
    expanded += `Blood type: ${ev.forensics.bloodType}.\n`
  }
  if (ev.forensics.timeIndicators) {
    expanded += `Time indicators: ${ev.forensics.timeIndicators}.\n`
  }
  if (ev.implications.reveals) {
    expanded += `\nThis evidence reveals: ${ev.implications.reveals}`
  }
  
  return expanded.trim()
}

function generateEvidenceHint(ev: Evidence): string | undefined {
  if (ev.implications.implicates.length > 0) {
    return `This evidence points toward ${ev.implications.implicates.join(' or ')}...`
  }
  if (ev.implications.exonerates.length > 0) {
    return `This clears ${ev.implications.exonerates.join(' and ')}`
  }
  return undefined
}

function generateDialogueUnlocksForEvidence(ev: Evidence): Array<{ characterId: string; prompt: string }> {
  const unlocks: Array<{ characterId: string; prompt: string }> = []
  
  // Unlock questions for implicated characters
  ev.implications.implicates.forEach(charId => {
    unlocks.push({
      characterId: charId,
      prompt: `Confront with evidence: ${ev.name}`
    })
  })
  
  return unlocks
}

function buildDialogueUnlocks(evidence: EvidenceBlueprint[]): Record<string, Array<{ characterId: string; prompt: string }>> {
  const map: Record<string, Array<{ characterId: string; prompt: string }>> = {}
  
  evidence.forEach(ev => {
    if (ev.dialogueUnlocks.length > 0) {
      map[ev.id] = ev.dialogueUnlocks
    }
  })
  
  return map
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

function generateTitle(mystery: GeneratedMystery): string {
  // Generate title from setting
  const location = mystery.setting.location
  return `The ${location} Mystery`
}

function generateSubtitle(mystery: GeneratedMystery): string {
  const event = mystery.setting.event
  return `Murder at ${event}`
}

function extractEra(date: string): string {
  // Extract era from date
  const year = parseInt(date.match(/\d{4}/)?.[0] || '1929')
  
  if (year >= 1920 && year < 1930) return '1920s'
  if (year >= 1930 && year < 1940) return '1930s'
  if (year >= 1940 && year < 1950) return '1940s'
  if (year >= 1950 && year < 1960) return '1950s'
  
  return '1920s' // Default
}

function extractWeather(mystery: GeneratedMystery): string {
  // Try to find weather in timeline or infer from season
  const date = mystery.setting.date.toLowerCase()
  
  if (date.includes('december') || date.includes('january') || date.includes('winter')) {
    return 'Cold, possibly snowing'
  }
  if (date.includes('june') || date.includes('july') || date.includes('summer')) {
    return 'Warm, clear evening'
  }
  
  return 'Atmospheric, setting the mood for mystery'
}

function generateAtmosphere(mystery: GeneratedMystery): string {
  const motive = mystery.killer.motive.type
  
  switch (motive) {
    case 'greed': return 'Tense, everyone eyes each other with suspicion'
    case 'revenge': return 'Dark, old wounds resurface'
    case 'fear': return 'Paranoid, secrets threaten to spill'
    case 'love': return 'Passionate, emotions run high'
    case 'power': return 'Calculating, a game of control'
    default: return 'Mysterious, noir atmosphere'
  }
}

function extractPublicKnowledge(mystery: GeneratedMystery): string[] {
  // Extract public timeline events as common knowledge
  return mystery.timeline
    .filter(event => event.isPublicKnowledge)
    .map(event => `${event.description} (${event.time})`)
}

function extractRedHerrings(mystery: GeneratedMystery): string[] {
  // All non-killer suspects with strong motives are red herrings
  const killerId = mystery.killer.characterId
  
  return mystery.suspects
    .filter(s => s.id !== killerId && s.secrets.some(sec => sec.blackmailable))
    .map(s => s.id)
}

function generateScoring(
  difficulty: 'easy' | 'medium' | 'hard',
  evidenceCount: number,
  suspectCount: number
): MysteryBlueprint['scoring'] {
  const baseTime = 30 + (suspectCount * 5) + (evidenceCount * 2)
  const multipliers = { easy: 0.8, medium: 1.0, hard: 1.3 }
  
  return {
    parTime: Math.round(baseTime * multipliers[difficulty]),
    maxScore: 1000,
    difficultyMultiplier: multipliers[difficulty],
    penalties: {
      wrongAccusation: 200,
      excessiveTime: 10
    },
    bonuses: {
      allEvidenceFound: 200,
      allContradictionsDiscovered: 150,
      underParTime: 100,
      firstAttemptCorrect: 250
    }
  }
}
